% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU): %
% ========================================
% %
% texlive-latex-base %
% texlive-latex-recommended %
% texlive-fonts-recommended %
% texlive-latex-extra %
% texlive-lang-spanish (en ubuntu 13.10) %
% ******************************************************** %

\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage[pdftex]{graphicx}
\usepackage{sidecap}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{makeidx}
\usepackage{float}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsfonts}
\usepackage{sectsty}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{pgfplots}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{listingsutf8}

\linespread{factor}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\pgfplotsset{compat=1.3}
\setlist[enumerate]{label*=\arabic*.}
\lstset{
	inputencoding=utf8/latin1,
	language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\bfseries\color{blue},
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{mygreen}\ttfamily,
	morecomment=[l][\color{magenta}]{\#},
	numbers=left,
	numberstyle=\color{mygray}
}

\input{codesnippet}
\input{page.layout}
\usepackage{caratula}

\newcommand{\ord}{\ensuremath{\operatorname{O}}}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}

%\lstset{
%    language=C++,
%    basicstyle=\ttfamily,
%    keywordstyle=\color{blue}\ttfamily,
%    stringstyle=\color{red}\ttfamily,
%    commentstyle=\color{ForestGreen}\ttfamily,
%    morecomment=[l][\color{magenta}]{\#}
%}

\begin{document}
\materia{Sistemas Operativos}
\submateria{Primer Cuatrimestre de 2016}
\titulo{Trabajo Práctico 1}
\subtitulo{Scheduling}
\integrante{Franco Frizzo}{013/14}{francofrizzo@gmail.com}
\integrante{Iván Pondal}{078/14}{ivan.pondal@gmail.com}
\integrante{Maximiliano Paz}{251/14}{m4xileon@gmail.com}

\maketitle
% no footer on the first page
\thispagestyle{empty}

\newpage
\section{Introducción}
En el presente informe, se relatan a grandes rasgos los pasos que fueron
necesarios para adaptar la implementación del juego \emph{Batalla Naval} y así
permitir la conexión simultánea de varios jugadores. Con este fin
se utilizó la biblioteca de POSIX Threads (\texttt{pthreads}), haciendo
cambios en el servidor de \emph{backend} que atiende los pedidos de los
distintos jugadores.

El informe se divide en dos secciones. En primer lugar, se detalla la
implementación de un \emph{read-write lock}, que fue necesario para ordenar
los accesos a los recursos compartidos del juego evitando que se produzcan
situaciones de \emph{deadlock} o inanición. En la segunda sección, se
especifican las modificaciones que se hicieron en el servidor propiamente
dicho y en la forma en que el mismo atiende cada una de las solicitudes de los
usuarios.

\section{Read-Write Lock}
Para cumplir con el requisito de que no haya inanición se necesitaron las
siguientes estructuras:

\begin{itemize}
    \item{Mutex \texttt{read\_write\_mutex}}
    \item{Variable condicional \texttt{turn\_cv}}
    \item{Contador de lectores \texttt{read\_count}}
    \item{Contador de escritores \texttt{writing\_count}}
    \item{Flag \texttt{writing}}
\end{itemize}

El problema de inanición está presente si al tener una secuencia no acotada
de pedidos de lectura o escritura al intentar la operación contraria esta queda
bloqueada. A continuación se explican las medidas necesarias para evitar que
suceda esto.

\subsection*{rlock()}
\begin{codesnippet}
\begin{verbatim}
Pedir mutex
Si el número de escritores es mayor a 0
    Esperar turno
Mientras haya una escritura en proceso
    Esperar turno
Aumentar en uno número de lectores
Liberar mutex
\end{verbatim}
\end{codesnippet}

A la hora de llamar a \texttt{rlock()} se pide el mutex
\texttt{read\_write\_mutex} y se procede a consultar si es posible la lectura.
Para esto se pide el valor de \texttt{writing\_count} donde si el mismo es mayor
a 0 entonces es necesario esperar ya que de otra forma no se podría frenar una
secuencia no acotada de pedidos de lectura. Además se consulta si la bandera
\texttt{writing} está alzada, ya que es aquí donde el thread se quedará
esperando hasta poder efectuar su lectura.

\subsection*{runlock()}
\begin{codesnippet}
\begin{verbatim}
Pedir mutex
Disminuir en uno número de lectores
Si el número de lectores es cero
    Dar turno a todos los que estén esperando uno
Liberar mutex
\end{verbatim}
\end{codesnippet}

Cuando se termina la lectura, con \texttt{runlock()} se disminuye el
valor de \texttt{read\_count} tal que en caso de llegar a 0 se despiertan
todos los threads que estuvieran esperando la condición \texttt{turn\_cv}. Esto
permite despertar a escritores que hubieran llegado en medio de una lectura.

\subsection*{wlock()}
\begin{codesnippet}
\begin{verbatim}
Pedir mutex
Aumentar en uno número de escritores
Mientras haya una escritura en proceso o el número de lectores sea mayor a cero
    Esperar turno
Subir bandera de escritura en proceso
Liberar mutex
\end{verbatim}
\end{codesnippet}

Con respecto a los pedidos de escritura mediante \texttt{wlock()}, lo primero
que se hace es aumentar el valor de \texttt{writing\_count} para que en caso de
llegar una pedido de lectura el mismo deba esperar. Luego se espera a que se
cumplan dos condiciones: que \texttt{writing = false} y \texttt{read\_count =
0}. Esto es necesario para evitar que haya más de una escritura en simultáneo y
que únicamente se escriba cuando no hay nadie leyendo. Esta condición se cumple
en algún momento ya que al llevar \texttt{writing\_count} a un valor mayor a 0 los
nuevos pedidos de lectura se ven obligados a esperar, permitiendo así que
\texttt{read\_count} disminuya más rápido de lo que aumenta llegando finalmente
a 0. En el caso de \texttt{writing} se sabe que a lo sumo hay un thread
escribiendo, por lo tanto el mismo tendrá que llamar a \texttt{wunlock()}
bajando la bandera.

\subsection*{wunlock()}
\begin{codesnippet}
\begin{verbatim}
Pedir mutex
Bajar bandera de escritura en proceso
Disminuir en uno número de escritores
Dar turno a todos los que estén esperando uno
Liberar mutex
\end{verbatim}
\end{codesnippet}
Una vez finalizada la escritura, \texttt{wunlock()} baja la bandera
\texttt{writing}, diminuye el número de escritores \texttt{writing\_count} y
despierta a todos los threads que estén esperando la variable condicional
\texttt{turn\_cv}.

\subsection{Inanición}

Como se explicó en el funcionamiento de la estructura, la misma cuenta con
mecanismos para evitar que queden pedidos ya sea de lectura o escritura sin
atender por una secuencia no acotada de la operación contraria. Básicamente esto
se reduce al hecho de que las lecturas deben esperar si el número de escritores
es mayor a 0 y los escritores a que no queden threads leyendo ni escribiendo.

Cabe destacar que parte del motivo por el cual esto funciona es que
\texttt{pthreads} asegura que si hay varios threads esperando a que se libere un
mutex, al recibir un signal habrá \emph{justicia} respecto quién lo recibe. Esto implica
que no puede haber un thread esperando eternamente a que se le otorgue un mutex.

\subsection{Deadlock}

Para demostrar que no hay deadlock alcanza con probar que no se cumple la
condición \emph{hold and wait}. Esta condición necesaria pero no suficiente para
que haya deadlock se cumple cuando hay un proceso que toma un recurso y no lo
libera hasta no tener todo lo necesario para poder ejecutar su tarea.

En el read-write lock esto ocurriría si un thread en caso de no poder escribir o
leer se quedará con el mutex, reteniéndolo hasta poder operar. Sin embargo,
todos los mutex son liberados en cuanto el thread decide esperar a su respectiva
variable de condición, por lo tanto nunca es retenido. A su vez, cuando un
thread es despertado y su condición se cumple, el mutex asociado es liberado.

Por lo tanto no es posible que haya \emph{hold and wait} en la implementación
desarrollada, evitando así la existencia de un deadlock.

\section{Backend}
Se espera que se conecten jugadores y por cada jugador se crea un thread.

Tenemos un mutex para acceder a los nombres de los equipos. Para diferenciar a
que equipo pertenece,  buscamos si alguno de los dos bandos que tenga ese nombre
lo agregamos a ese equipo, caso contrario si todavia no se crearon los dos
grupos se crea uno con su nombre, si ya existian los dos equipo se elimina ese
thread.

Para colocar una ficha, se usa el lock de lectura, revisamos si la ficha a
colocar es valida, si lo es se cierra el lock y se abre el lock de escritura,
luego se revisa si ese casillero todavia esta libre, si lo esta se agrega esa
ficha al barco actual y se pone el casillero donde iria la ficha como ocupado,
luego se cierra el lock de escritura. En caso contrario se borra el barco en
construccion.  Para borrar el barco en construccion se usa el lock de escribir y
se limpia el tablero se borra el barco.

Tenemos un mutex para el contador la cantidad de jugadores que faltan para
empezar el juego.Cada vez se une un jugador se aumenta el contador, si un
jugador fue eliminado ó envia el comando \'listo\', el contador disminuye en 1,
cuando  es $0$ empieza la batalla.

\end{document}
